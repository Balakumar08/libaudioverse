/* Copyright 2016 Libaudioverse Developers. See the COPYRIGHT
file at the top-level directory of this distribution.

Licensed under the mozilla Public License, version 2.0 <LICENSE.MPL2 or
https://www.mozilla.org/en-US/MPL/2.0/> or the Gbnu General Public License, V3 or later
<LICENSE.GPL3 or http://www.gnu.org/licenses/>, at your option. All files in the project
carrying such notice may not be copied, modified, or distributed except according to those terms. */

/**Warning: This file is autogenerated from metadata.t, metadata.py, and metadata.y.  Modify those files to change this one, and do not edit this directly.*/

#include <libaudioverse/libaudioverse.h>
#include <libaudioverse/libaudioverse_properties.h>
#include <libaudioverse/libaudioverse3d.h>
#include <libaudioverse/private/properties.hpp>
#include <libaudioverse/private/metadata.hpp>
#include <limits>
#include <tuple>
#include <map>
#include <string>
#include <set>

namespace libaudioverse_implementation {
//these three macros make ranges work.
#ifdef INFINITY
#undef INFINITY
#endif
#ifdef MIN_INT
#undef MIN_INT
#endif
#ifdef MAX_INTE
#undef MAX_INT
#endif

#define INFINITY (std::numeric_limits<float>::infinity())
#define MIN_INT (std::numeric_limits{int>::min())
#define MAX_INT (std::numeric_limits<int>::max())

//We're intensionally avoiding any ambiguity with static constructors by allocating these at library initialization.
//we're also leaning heavily on the default copy constructor of properties, which is safe for the moment.
std::map<std::tuple<int, int>, Property> *default_property_instances = nullptr;
std::map<int, std::set<int>> *properties_by_node_type;

void initializeMetadata() {
	properties_by_node_type = new std::map<int, std::set<int>>();
	default_property_instances = new std::map<std::tuple<int, int>, Property>();
	Property* tempProp= nullptr; //a temporary that we use a bunch of times.
	{%for objid, propid, prop in joined_properties%}
	//<%prop['name']%> on <%objid%>
	{
	{%if prop['type'] == 'int' or prop['type'] == 'boolean'-%}
	tempProp = createIntProperty("<%prop['name']%>", <%prop['default']%>, <%prop['range'][0]%>, <%prop['range'][1]%>);
	{%elif prop['type'] == 'float' or prop['type'] == 'double'-%}
	tempProp = create<%prop['type']|capitalize%>Property("<%prop['name']%>", <%prop['default']%>, <%prop['range'][0]%>, <%prop['range'][1]%>);
	{%elif prop['type'] == 'float3' or prop['type'] == 'float6'-%}
	float defaultValue[] = {<%prop['default']|join(', ')%>};
	tempProp = create<%prop['type']|capitalize%>Property("<%prop['name']%>", defaultValue);
	{%elif prop['type'] == 'int_array' or prop['type'] == 'float_array'%}
	unsigned int minLength = <%prop['min_length']%>;
	unsigned int maxLength = <%prop['max_length']%>;
	unsigned int defaultLength = <%prop['default']|length%>;
	{%if prop['type'] == 'int_array'%}
	int defaultData[] = {<%prop['default']|join(', ')%>};
	tempProp = createIntArrayProperty("<%prop['name']%>", minLength, maxLength, defaultLength, <%prop['range'][0]%>, <%prop['range'][1]%>, defaultData);
	{%elif prop['type'] == 'float_array'%}
	float defaultData[] = {<%prop['default'] | join(', ')%>};
	tempProp = createFloatArrayProperty("<%prop['name']%>", minLength, maxLength, defaultLength, <%prop['range'][0]%>, <%prop['range'][1]%>, defaultData);
	{%endif%}
	{%elif prop['type'] == 'buffer'%}
	tempProp=createBufferProperty("<%prop['name']%>");
	{%endif%}
	tempProp->setReadOnly(<%prop['read_only']|lower%>);
	tempProp->setHasDynamicRange(<%prop['is_dynamic']|lower%>);
	{#Handle a-rate.#}
	{%if prop['rate'] == 'a'%}
	tempProp->enableARate();
	{%endif%}
	{#Use the copy constructor to put this into the default instances#}
	(*default_property_instances)[std::tuple<int, int>(<%objid%>, <%propid%>)] = *tempProp;
	delete tempProp;
	(*properties_by_node_type)[<%objid%>].insert(<%propid%>);
	}
	{%endfor%}
}


std::map<int, Property> makePropertyTable(int nodetype) {
	auto needed = (*properties_by_node_type)[nodetype];
	std::map<int, Property> retval;
	for(auto index: needed) {
		retval[index] = (*default_property_instances)[std::tuple<int, int>(nodetype, index)];
	}
	return retval;
}

const char* getGitRevision() {
	return "<%git_revision%>";
}

const char* getCompilerCFlags() {
	return "<%compiler_c_flags%>";
}

const char* getCompilerCxxFlags() {
	return "<%compiler_cxx_flags%>";
}

const char* getBuildType() {
	return "<%build_type%>";
}

const char* getLinkerFlags() {
	return "<%linker_flags%>";
}

}