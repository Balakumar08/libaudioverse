"""This is the base class for all bindings generator backends.

See also metadata_description.py, which defines the classes that represent Libaudioverse objects. Your backend will receive instances of them.
"""
import abc
from abc import abstractmethod
import jinja2
import os
import os.path

class BackendBase(metaclass = abc.ABCMeta):
    """A bindings generator backend.

This class defines a number of methods which are called by the bindings generator, Jinja2 filters, and some utilities.
visit_ methods are called on individual objects.
begin_ and end_methods are called to begin/end sections.
Functions are called by the generator in the order specified in this file.

You need to use the API for writing files that is provided by this class.  Libaudioverse may do dry runs of bindings generation for continuous integration or otherwise send the files to places that are not the hard disk.

This is an abstract class. You must implement all abstract methods.

This class provides a Jinja2 context as the context member and a render helper method.
Any function beginning with jfilt_ will be inserted as a filter  and any function beginning with jfn_ as a function.
You must implement the minimal filters provided here, but may provide more.
Unless disabled, all text files you write will be passed through Jinja2 after generation and before going to disk.

The transformers in transformers.py are always available to your templates under their names in that file.
You can override one here with the jfilt_ mechanism. Don't.

Render all templates through self.render.

Many backends need to include files that do not necessarily need to be generated.
if the backend contains a directory called prepopulate, then the prepopulate function will automatically be called.
This sets things up such that prepopulate/test.txt will appear as test.txt in the output directory, and requests for a builder for test.txt will be prefilled with the contents of test.txt.
This facility will not work on binary files.

Public members of this class are fair game.  Don't screw with the private ones.
"""

    # The following can be changed in subclasses.
    indent  = "    " #String to use for indenting.
    suppress_whitespace_lines = True # If false, don't eliminate whitespace from blank lines. Convenience to allow builder += ""
    encoding = "utf8" # The encoding for text files, when written to disk.
    needs_build = True # Whether to call build. If false, use the source generated by the backend as the release artifacts.
    platform_specific = False # If true, build artifacts are placed under platform-specific directories; see docstring on build for details.

    def __init__(self, backend_path):
        """Subclasses should use *args and **kwargs, passing everything through unmodified. The parameter list here is not guaranteed to be stable."""
        self.jinja2_environment = jinja2.Environment(trim_blocks = True)
        self._output_files_text = dict() # A dict of lists of lines, the source code files to write.
        self._output_files_binary = dict() # The binary files to include.
        self.backend_path = backend_path
        if os.path.exists(os.path.join(backend_path, "prepopulate")):
            self.prepopulate("prepopulate")

    @abstractmethod
    def visit_enum(self, info):
        """Called on all enums, including Lav_ERRORS."""
        pass

    @abstractmethod
    def visit_typedef(self, name, type):
        """Called on all typedefs in the order they're declared in libaudioverse.h."""
        pass

    @abstractmethod
    def visit_error_enum(self, info):
        """Visit the error enum to translate values to exceptions or similar.  Called on all members of the enum, but not the enum itself."""
        pass

    @abstractmethod
    def visit_c_function(self, info):
        """Called on all functions in the C header."""
        pass

    @abstractmethod
    def begin_node(self, node_info):
        """Begin binding a specific node."""
        pass

    @abstractmethod
    def begin_properties(self, node_info):
        """Begin binding properties."""
        pass

    @abstractmethod
    def visit_property(self, node_info, property_info):
        """Bind a property."""
        pass

    @abstractmethod
    def end_properties(self, node_info):
        """We're done with properties."""
        pass

    @abstractmethod
    def begin_callbacks(self, node_info):
        """We're going to bind all the callbacks."""
        pass

    @abstractmethod
    def visit_callback(self, node_info, callback_info):
        """Visit a callback."""
        pass

    @abstractmethod
    def end_callbacks(self, node_info):
        """We're done binding callbacks."""
        pass

    @abstractmethod
    def begin_extra_functions(self, node_info):
        """Visit this node's extra functions."""
        pass

    @abstractmethod
    def visit_extra_function(self, node_info, function_info):
        """Bind an extra function."""
        pass

    @abstractmethod
    def end_extra_functions(self, node_info):
        """End binding of extra functions."""
        pass

    @abstractmethod
    def end_node(self, info):
        """We're done binding a specific node."""
        pass

    @abstractmethod
    def build(self):
        """Build release artifacts.  Return an iterable of (source, destination) tuples.

This function is called with the working directory set to the destination for all produced files, with all files in place.
The source path should be either an absolute path, or relative to this directory.  The destination path should be relative.
All files produced by this process are copied to somewhere/<language>/destination.
If platform_specific is true (not the default), this becomes somewhere/<language>/<platform>/destination.
For some languages (i.e. Python), artifact names include the platform; for others (i.e. C++), the user builds it themselves.
If source is a directory, then the whole directory's contents will be copied to destination, including empty directories."""
        pass

    # Utility functions.

    def prepopulate(self, path):
        """Prepopulate this bindings generator with the contents of a directory, adding them to the output as if you had copied the contents of the directory.

The path is relative to the location of your backend.  After this function is called, requests for specific files will prepopulate the CodeBuilder as if you had read them and added the lines yourself.

Do not use this on a directory containing binary files.  See the class docstring for more details."""
        abspath = os.path.abspath(os.path.join(self.backend_path, path))
        for (dirpath, dirname, files) in os.walk(abspath):
            for p in [os.path.join(dirpath, j) for j in files]:
                p = os.path.abspath(p)
                relpath = os.path.relpath(p, abspath)
                builder = self.get_builder(relpath)
                builder.append_file(p)

    def get_builder(self, path):
        """Given a path, create a CodeBuilder."""
        builder = CodeBuilder(self, path, indent = self.indent)
        return builder

    def render(self, text, **kwargs):
        """Render a Jinja2 template, with kwargs as the context."""
        template = self.jinja2_environment.from_string(text, globals = kwargs)
        return template.render(kwargs)

class CodeBuilder:
    """This class represents a destination for code.  You need to use it instead of files.  Instantiate it with get_builder.

As a convenience, lines can be appended with +=.  If you append more than one line, all lines are indented to the current level."""

    def __init__(self, backend, path, indent = "    "):
        self.backend = backend
        self.path = path
        if path not in self.backend._output_files_text:
            self.backend._output_files_text[path] = []
        self._text = self.backend._output_files_text[path]
        self._indent_level = 0
        self._indent = indent

    def write(self, text, allow_indent = True):
        text = text.replace("\r", "").split("\n")
        for line in text:
            if allow_indent and len(line):
                line = self._indent*self._indent_level + line
            self._text.append(line)

    def __iadd__(self, other):
        """Convenient way to add lines."""
        self.write(other)

    def indent(self):
        self._indent += 1

    def outdent(self):
        self._indent -= 1
        if self._indent < 0:
            raise ValueError("Attempt to outdent more than you indented.")

    def append_file(self, path):
        with open(path) as f:
            text = f.read()
            lines = text.split("\n")
            for i in lines:
                self.write(i, allow_indent = False)
