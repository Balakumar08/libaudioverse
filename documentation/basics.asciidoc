[[basics]]
== Basic Concepts of Libaudioverse

In order to begin using Libaudioverse's 3d components, it is not necessary to fully understand this section.
For a gentler and much more hands-on introduction, see the tutorials.

[[basics-simulation]]
=== The Simulation

The simulation is the main entry point to Libaudioverse.
When created, the simulation fixes the sampling rate and block size of all nodes that use it.

For efficiency, Libaudioverse audio is processed in blocks.
At the beginning of each block, properties are read and updated, node connections examined,  and audio synthesized.
The most useful way to think of the block size is the number of samples for which any node connections and property settings are fixed.

More concretely, when the simulation has an associated output device, the block size is the number of frames of audio that will be submitted to the sound card at once.
Otherwise, it is the number of frames of audio returned by a call to `Lav_getBlock`.

See <<basics-audio-output,the section on outputting audio>> for information about associating the simulation to an audio output device.

If an app is changing multiple properties, it is possible for Libaudioverse to decide to mix a block before they are all at their new values.
To prevent this, the simulation may be treated like a lock.
While locked, all other threads (including the internal mixer thread) will be unable to access this simulation or its objects.
In the C API, this is available through `Lav_simulationLock` and `Lav_simulationUnlock`.

IMPORTANT: Locking the simulation is not called something else for a reason.
If you fail to apply all the considerations you would apply to regular locks, deadlock will result.
Note that all objects lock their simulations when accessed.
If your app uses multiple simulations and also locks more than one of them at any point, then be careful not to access objects from the other simulation.

If the requirement for syncing with audio perfectly exists, the block callback may be used.
If set, it will be called every block, receiving the simulation and the simulation's current time as parameters.
Code in this function can be thought of as executing between a `Lav_simulationLock` and `Lav_simulationUnlock` pair, and all the same considerations apply.
This is by far the most complicated way to drive Libaudioverse, but is helpful when implementing event timelines or virtual instruments.

[[basics-buffers]]
=== Buffers

Buffers are the simplest Libaudioverse object: they hold audio data.
This data can come from anywhere and be at any sampling rate.
When the buffer's data is set, the data in it is resampled to match the sampling rate of the simulation used to create it.

Buffers are intended to allow many copies of the same data to be in use simultaneously.
Instead of loading multiple copies of a file or other data,
it is possible to use the same buffer handle in multiple places.
In addition, the expensive resampling operation need only occur once.

Due to the resampling, buffers are not ideal for streaming; if you need streaming, use a streaming file node, pull node or push node.

[[basics-nodes]]
=== Nodes

Nodes can be thought of as black boxes that manipulate audio.
The following lists some things that nodes can do, roughly in the order that you will need them.

- Produce audio, for example the buffer node and the sine node.
- Modify audio, for example the biquad and IIR filter sections.
- perform analysis or otherwise allow observation of audio as it passes through Libaudioverse.
- Execute side effects like recording to files.

If there is not a node that does what you want, it is even possible to make your own.

If the simulation is the entry point of Libaudioverse, the node is the actual functionality.
Since it is difficult to separate nodes from other concepts, most of the explanation of their features is in other subsections.
Every node will run at most once per block, as described <<basics-audio-processing,here>>.
Inputs and outputs are discussed <<basics-inputs-outputs,here>>.
The specifics of properties are also discussed in a dedicated section, <<basics-properties,namely this one>>.

While properties are discussed later, one deserves special mention here. Every node has a state, either playing, always playing, or paused.  The specific meanings of these are discussed below alongside the audio algorithm, but references to a node's state refer to this property.

[[basics-properties]]
=== Properties

Every node can have any number of properties.
To find out specifically which properties a specific node of interest has, see the node reference.

There are two broad categories of properties: k-rate and a-rate.
These terms are borrowed from other systems similar to Libaudioverse.
A k-rate property is evaluated at the beginning of a block and not read again until the next block;
an a-rate property is read every sample.
Only float and double properties can be a-rate.

The following types of properties are present in Libaudioverse:

- Boolean: Holds 0 or 1.
In the C API, this is manipulated using the functions for int properties.
The distinction is only important in language bindings, which map boolean to the language's native boolean type.
- Int: holds a 32-bit integer.
- Float: Holds a 32-bit floating point value.
- Double: Holds a64-bit double.
- Buffer: Holds a reference to a buffer.
- Float3: Holds a vector of 3 floats, primarily for position in the 3D audio components of this library.
All 3 components must be updated at once.
- Float6: Holds a vector of 6 floats, also for use primarily by the 3D components.
All 6 components must be updated at once.
- Int array: Holds an array of integers with limits on its length.
- Float array: Holds an array of floats with limits on its length.
- String: A string.

Float and double properties need further discussion.
A float or double property, hereafter an automatable property, has a couple extra features.

The first of these is that it is possible to connect nodes to automatable properties, in much the same way that one connects nodes to other nodes.
When this happens, the audio of all connected nodes is downmixed to mono, added, and used as an offset on the property's set value.

Automatable properties also support automators, a concept borrowed directly from Web Audio.
An automator moves the value of a property according to a specific instruction.  The current automators are as follows:

- Linear ramp to value: moves the property to a specific value by a specific time.

In the various programming language bindings, automation methods are found on the classes which represent the properties themselves.
For example, in Python, `mysine.frequency.linear_ramp_to_value(1.0, 500.0)` will move the frequency of the sine node from where it is now to 500.0 HZ over 5 seconds.

Changing the value of an automatable property will cancel all automators while leaving nodes connected.
If you wish to disconnect nodes, you must do so manually.

To be more formal, the value of an automatable property for time `t` where `t` is relative to the node's current time is computed as follows:

- If the property is a k-rate property, adjust `t` to the beginning of the block.
- Let the intrinsic value be the value of the property or, if the property has automators scheduled, the value of those automators at `t`.
- let the node value be the value of all connected nodes at `t`, summed.
- The value of the property is the sum of the intrinsic and node values.

