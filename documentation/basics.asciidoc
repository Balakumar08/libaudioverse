[[basics]]
== Basic Concepts of Libaudioverse

In order to begin using Libaudioverse's 3d components, it is not necessary to fully understand this section.
For a gentler and much more hands-on introduction, see the tutorials.

[[basics-general-overview]]
=== General Overview of Libaudioverse Concepts

Libaudioverse has three main types of object:

- The simulation represents a collection of nodes and mixes audio.
- Nodes process or produce audio.
- Buffers hold chunks of audio data.

Each of these is discussed below.

[[basics-simulation]]
==== The Simulation and Audio Mixing

The simulation is the main entry point to Libaudioverse.
When created, the simulation fixes the sampling rate of all nodes that use it.
There are two types of simulation: a regular simulation and a read simulation.
Regular simulations automatically advance audio and associate themselves with audio devices at initialization.
Read simulations do not advance audio unless you ask them for a block.
Where this distinction is important, this manual will make a point of distinguishing; hereafter you can take "the simulation" to mean both unless otherwise specified.

Every simulation has two key parameters: the sampling rate and the block size.

The sampling rate is exactly what it sounds like.  When in doubt, use 44100, as this is sufficient for most purposes.

Libaudioverse processes audio in blocks.
When audio is being processed, the simulation locks an internal lock, blocking all incoming Libaudioverse calls that refer to that simulation or nodes which are a part of it.
It then produces the next block of audio before releasing this lock, allowing your code to continue making calls.
The block size is the size of this block.
In effect, the block size is the number of samples for which any property values are fixed; properties are described below.

Regular simulations add two more parameters.

The first of these is called mixahead and deserves some discussion.
When audio is produced, it has to be produced slightly in advance of realtime.
This is due to the fact that Libaudioverse may be pre-empted by the OS.
If Libaudioverse produced a block and then waited for it to be completely finished before beginning the next one, audio would click continuously.
Furthermore, smaller block sizes take more CPU because of the overhead of starting a block, yet smaller block sizes increase audio quality.
To deal with this, Libaudioverse maintains a queue of blocks.
If the queue is not full, then more blocks will be produced without waiting.
Mixahead is the limit on this queue.

The simplest way to look at mixahead is as a latency in blocks.
If you want to know approximately how much latency Libaudioverse is introducing, use the following expression: `block_size*sample_rate/mixa_ahead`.

A mixahead of 0 will click for almost everyone.
As a general guideline, a latency of 100 MS will work for most people.
Furthermore, block size should usually be no more than 1024, as this is about the point where rapid property changes become audible as discrete events.
This implies that your mixahead should usually be greater than 4.
Lowering the block size usually means raising the mixahead, so larger values are certainly possible.

Unfortunately, the situation is yet more complicated.
These settings will work for almost everyone, but you should allow your user to change them.
In this case, almost  everyone includes setups with very high latencies, for example bluetooth headphones.
It is suggested that you put a latency slider in your advanced options, and allow the user to move it in units of `block_size/sr`.
Note: this will become easier, but mixahead is currently fixed at simulation start-up.

Simulations provide the ability to perform an atomic operation, so called because I have not yet found a better name.
When making multiple calls to change aspects of audio, it is possible for the user to hear intermediate changes.
This occurs because Libaudioverse might decide to process a lock between them.
An atomic operation acquires the internal Libaudioverse lock, preventing all threads save the current one from accessing this simulation and its nodes.
This includes Libaudioverse's internal threads for mixing.

This is exposed via your language binding in the usual manner for locks, and you should treat this feature with the same level of caution.
For example, Python only allows use of this feature via with blocks.
Think of this as acquiring a lock that protects the simulation: if you wait on a lock that is held by another thread that is also calling Libaudioverse in such a way that this simulation is required, you can deadlock.

Finally, simulations provide the ability to execute code in the audio thread.
This allows you to write code that can update the nodes you are using without ever missing a block.
The callback receives the simulation and the simulation's current time as parameters.
because it is running in the audio thread, this callback should try its best not to block.
Unlike some other audio libraries, blocking here is perfectly fine, but it will slow down audio mixing.
In addition, you are executing inside the critical section of the audio thread, so other threads of your application that may need to access this simulation will not be able to make progress.
It is not only safe to call Libaudioverse functions, but expected.
The only rule you must not break here is this: do not access another simulation or an object belonging to another simulation.
This is the most complicated way to write code that drives libaudioverse, and is primarily intended for synthesizers and the development of instruments, where the greatest concern is on precise, sample-accurate  timing.